name: Continuous Deployment

on:
  workflow_run:
    workflows: ["Continuous Integration"]
    types:
      - completed
    branches: [main, develop]
  
  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      image_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: nequi-franquicias

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success'
    
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should-deploy: ${{ steps.env.outputs.should-deploy }}
      
    steps:
    - name: Determine deployment environment
      id: env
      run: |
        if [[ "${{ github.event.workflow_run.head_branch }}" == "main" ]]; then
          echo "environment=staging" >> $GITHUB_OUTPUT
          echo "should-deploy=true" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event.workflow_run.head_branch }}" == "develop" ]]; then
          echo "environment=development" >> $GITHUB_OUTPUT
          echo "should-deploy=true" >> $GITHUB_OUTPUT
        else
          echo "should-deploy=false" >> $GITHUB_OUTPUT
        fi

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.should-deploy == 'true'
    
    environment: 
      name: ${{ needs.determine-environment.outputs.environment }}
      
    outputs:
      cluster-name: ${{ steps.terraform.outputs.cluster-name }}
      service-name: ${{ steps.terraform.outputs.service-name }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        terraform_wrapper: false
        
    - name: Terraform Init
      working-directory: infrastructure/terraform
      run: terraform init
      
    - name: Terraform Plan
      working-directory: infrastructure/terraform
      run: |
        terraform plan \
          -var="environment=${{ needs.determine-environment.outputs.environment }}" \
          -var="image_tag=${{ github.sha }}" \
          -out=tfplan
          
    - name: Terraform Apply
      id: terraform
      working-directory: infrastructure/terraform
      run: |
        terraform apply -auto-approve tfplan
        
        # Export outputs
        echo "cluster-name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
        echo "service-name=$(terraform output -raw service_name)" >> $GITHUB_OUTPUT

  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure]
    
    environment: 
      name: ${{ needs.determine-environment.outputs.environment }}
      
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Deploy to ECS
      run: |
        # Get current task definition
        TASK_DEFINITION=$(aws ecs describe-task-definition \
          --task-definition ${{ needs.deploy-infrastructure.outputs.service-name }} \
          --query taskDefinition)
        
        # Update image in task definition
        NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE "${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}" \
          '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
        
        # Register new task definition
        NEW_TASK_DEF_ARN=$(echo $NEW_TASK_DEFINITION | aws ecs register-task-definition --cli-input-json file:///dev/stdin --query 'taskDefinition.taskDefinitionArn' --output text)
        
        # Update service
        aws ecs update-service \
          --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
          --service ${{ needs.deploy-infrastructure.outputs.service-name }} \
          --task-definition $NEW_TASK_DEF_ARN
          
    - name: Wait for deployment
      run: |
        aws ecs wait services-stable \
          --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
          --services ${{ needs.deploy-infrastructure.outputs.service-name }}

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure, deploy-application]
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Get service URL
      id: service-url
      run: |
        # Get load balancer DNS name
        LB_DNS=$(aws ecs describe-services \
          --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
          --services ${{ needs.deploy-infrastructure.outputs.service-name }} \
          --query 'services[0].loadBalancers[0].targetGroupArn' --output text | \
          xargs aws elbv2 describe-target-groups --target-group-arns | \
          jq -r '.TargetGroups[0].LoadBalancerArns[0]' | \
          xargs aws elbv2 describe-load-balancers --load-balancer-arns | \
          jq -r '.LoadBalancers[0].DNSName')
        
        echo "url=http://$LB_DNS" >> $GITHUB_OUTPUT
        
    - name: Health check
      run: |
        echo "Checking health at ${{ steps.service-url.outputs.url }}/actuator/health"
        
        # Wait for service to be ready
        for i in {1..30}; do
          if curl -f "${{ steps.service-url.outputs.url }}/actuator/health"; then
            echo "‚úÖ Health check passed"
            break
          else
            echo "‚è≥ Waiting for service to be ready... ($i/30)"
            sleep 10
          fi
        done

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure, deploy-application, health-check]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Java 25
      uses: actions/setup-java@v4
      with:
        java-version: '25'
        distribution: 'oracle'
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Get service URL
      id: service-url
      run: |
        LB_DNS=$(aws ecs describe-services \
          --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
          --services ${{ needs.deploy-infrastructure.outputs.service-name }} \
          --query 'services[0].loadBalancers[0].targetGroupArn' --output text | \
          xargs aws elbv2 describe-target-groups --target-group-arns | \
          jq -r '.TargetGroups[0].LoadBalancerArns[0]' | \
          xargs aws elbv2 describe-load-balancers --load-balancer-arns | \
          jq -r '.LoadBalancers[0].DNSName')
        
        echo "url=http://$LB_DNS" >> $GITHUB_OUTPUT
        
    - name: Run integration tests
      run: ./gradlew integrationTest
      env:
        API_BASE_URL: ${{ steps.service-url.outputs.url }}
        SPRING_PROFILES_ACTIVE: integration

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure, deploy-application, health-check, integration-tests]
    if: failure()
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Rollback deployment
      run: |
        echo "üîÑ Rolling back deployment..."
        
        # Get previous task definition
        PREVIOUS_TASK_DEF=$(aws ecs describe-services \
          --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
          --services ${{ needs.deploy-infrastructure.outputs.service-name }} \
          --query 'services[0].deployments[1].taskDefinition' --output text)
        
        if [ "$PREVIOUS_TASK_DEF" != "None" ]; then
          # Rollback to previous version
          aws ecs update-service \
            --cluster ${{ needs.deploy-infrastructure.outputs.cluster-name }} \
            --service ${{ needs.deploy-infrastructure.outputs.service-name }} \
            --task-definition $PREVIOUS_TASK_DEF
            
          echo "‚úÖ Rollback completed"
        else
          echo "‚ùå No previous version found for rollback"
        fi

  notify:
    name: Notify Team
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure, deploy-application, health-check, integration-tests]
    if: always()
    
    steps:
    - name: Notify Slack on success
      if: needs.integration-tests.result == 'success'
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#deployments'
        text: |
          ‚úÖ Deployment successful to ${{ needs.determine-environment.outputs.environment }}
          üöÄ Version: ${{ github.sha }}
          üåê Environment: ${{ needs.determine-environment.outputs.environment }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        
    - name: Notify Slack on failure
      if: needs.integration-tests.result == 'failure' || needs.health-check.result == 'failure' || needs.deploy-application.result == 'failure'
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#deployments'
        text: |
          ‚ùå Deployment failed to ${{ needs.determine-environment.outputs.environment }}
          üöÄ Version: ${{ github.sha }}
          üîÑ Rollback initiated
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
